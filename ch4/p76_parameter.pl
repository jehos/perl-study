#!/usr/bin/env perl

use 5.010;
use strict;
use warnings;

=pod

=encoding utf-8

=head1 인자

사용자 함수는 인자값을 처리할 수 있다, B<함수 호출 뒤에 목록 표현식> 을
입력해주면 함수를 실행함과 동시에 목록이 인자로 넘어가게 된다.

이 과정은, 함수가 설령 인자가 필요하지 않다 하더라도 일단 넘어가게된다.
C 나 JAVA 같은 언어에서 명시적으로 형식매개변수를 선언하는 모습과는 다르다.

이때 넘어간 인자의 목록은 C<@_> 라는 블록내의 사설변수에 저장되게 된다.
C<@_> 는 사설변수이기 때문에, 중첩되어 호출되더라도 값을 유지한다.
사용자 함수는 C<@_> 에서 갯수와 값을 판단하게 된다.

	sub max {
		if ($_[0] > $_[1]){
			$_[0];
		} else {
			$_[1];
		}
	}

	&max(10, 15)

=cut


sub max {
	if ($_[0] > $_[1]){
		$_[0];
	} else {
		$_[1];
	}
}
say &max(10, 15);


=head1 인자값의 한정

그러나 이 방법에는 문제가 있는것이, 사용자 함수에서 요구하는 인자의 갯수를
한정하지 못하는 문제가 있다.

가령 상기의 예제에서 C<&max(10, 15, 20)> 과 같은 형태로 입력했다면,
3번째 인자는 탈락될것이다.

초과하는 매개변수와 마찬가지로 모자라는 매개변수에 대해서도 무시한다.
만약 없는 요소에 접근하려고 한다면 undef 를 반환할 것이다.

만약 인자의 갯수가 올바른지 확인하려면 내부에 확인부분을 넣어야 한다.

	sub	max {
		if (@_ == 2) {
			my ($m, $n) = @_;
			if ($m > $n) { $m } else { $n }
		}
	}

=cut


sub	max_b {
	if (@_ == 2){
		my ($m, $n) = @_;
		if ($m > $n) { $m; } else { $n; }
	}
}

say if ($_ = &max_b(10, 15, 20));


=head1 왠만하면 하지 말아야 할 것

=over

=item 명확하지 않은 묵시적인 반환값

함수안에서 굳이 return 문을 쓰지 않아도 마지막 연산에 대해서 리턴하게 된다.
그러나 코드를 봤을때 한번에 명확하게 인지하기가 힘드므로,
가능하면 명시적으로 return 으로 정확히 어떤값이 리턴되는지 알려라.

=item undef 가 반환될 수 있음을 인지할것

가끔은 undef 가 반환될 수 있다. 보통의 경우라면 별 문제가 없겠지만,
목록문맥에 반환된 undef가 대입되면, 해당 목록문맥은 undef 라는 스칼라값을
가진 목록으로써, 참으로 치부될 수 있다.
undef 가 반환될 수 있음을 유의하자.

=back

=cut


=head1 &max 함수의 개량

인수가 몇개 들어오더라도 처리할 수 있도록 개선해 보면 다음과 같다

=cut

sub max_c {
	my $max_so_far = shift @_;
	foreach (@_) {
		if ($_ > $max_so_far) {
			$max_so_far = $_;
		}
	}

	return $max_so_far;
}

say my $maximum = &max_c(3, 5, 10, 4, 6);

